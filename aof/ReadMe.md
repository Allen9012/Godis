在进行AOF重写操作时需要满足两个要求:

若 AOF 重写失败或被中断，AOF 文件需保持重写之前的状态不能丢失数据
进行 AOF 重写期间执行的命令必须保存到新的AOF文件中, 不能丢失
因此我们设计了一套比较复杂的流程：

暂停AOF写入 -> 更改状态为重写中 -> 准备重写 -> 恢复AOF写入
重写协程读取 AOF 文件中的前一部分（重写开始前的数据，不包括读写过程中写入的数据）并重写到临时文件（tmp.aof）中
暂停AOF写入 -> 将重写过程中产生的新数据  写入tmp.aof -> 使用临时文件tmp.aof覆盖AOF文件（使用文件系统的mv命令保证安全 -> 恢复AOF写入

rewrite/FinishRewrite 
具体的逻辑如下:
首先，获取 Persister 对象中维护的 aofFilename 文件名，打开该文件。
根据 RewriteCtx 对象中的 fileSize 字段，定位 aof 文件中需要被重写的部分，将文件指针移到该位置。
向临时文件中写入一个 SELECT 命令，以确保该文件与在线的 AOF 文件中的数据库状态一致。
将 aof 文件中的剩余部分，即重写点后的命令序列，复制到临时文件中。
关闭临时文件，记录其文件名。
关闭 Persister 对象中维护的 aofFile，用临时文件替换旧的 AOF 文件。
重新打开 aofFile，为接下来的命令写入做准备。
向新的 aofFile 中写入一个 SELECT 命令，以确保其数据库状态与 Persister 对象中的状态一致。
这段代码的主要作用是对 Redis 中的 AOF 机制进行优化，将较老的命令序列压缩并重写到新的文件中，减小 AOF 文件的大小，提高 Redis 数据库的性能。